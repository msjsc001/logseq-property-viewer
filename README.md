# Logseq 属性查询与统计 TUI 工具 v2.0

这是一个独立于 Logseq 软件之外的高性能终端工具，用于对 Logseq 知识库中的 Markdown 文件进行高级的**属性查询**和**数据统计**，并以友好的终端用户界面（TUI）展示结果。

<img alt="PixPin_2025-09-22_17-55-18" src="https://github.com/user-attachments/assets/38655228-f595-4502-9d4a-867cde065cae" />

---

## ✨ 核心功能

- **智能增量缓存**:
    - **首次加速**：第一次运行时，工具会全面扫描知识库并建立缓存。
    - **闪电更新**：后续运行时，仅需数秒即可完成对新增、修改或删除文件的增量检查，极大提升了大型知识库的启动和分析速度。
    - **手动管理**：提供手动更新缓存和一键清理所有缓存的功能。

- **高级属性查询**:
    - 支持精确匹配 (`key:value`)、模糊匹配 (`key~value`) 和存在性匹配 (`has:key`)。
        - has:key 用法是输入 `has:` 后输入`键` 就可以查询到所有包含这个键的内容。
    - 支持 `AND` / `OR` 逻辑运算符进行复杂条件组合。
    - 查询结果以动态表格展示，自动生成列，并支持点击表头排序。
    - **列筛选**：支持在查询结果中动态选择显示或隐藏特定的属性列。
    - **快速跳转**：在查询结果中选中一行，可直接调用 Logseq URI 打开对应的页面。

- **数据统计与分析**:
    - 一键扫描并分析整个知识库，找出所有使用过的属性“键”。
    - **联想搜索**：支持通过输入关键词，实时筛选数量庞大的属性键列表。
    - 以表格和文本条形图的形式，直观展示任一属性键的值分布情况。

- **高性能与用户体验**:
    - **多线程处理**：核心的文件解析过程采用多线程处理，有效利用多核 CPU 性能。
    - **TUI 界面**：基于 `Textual` 构建，界面响应流畅，支持鼠标和键盘操作。
    - **状态持久化**：自动保存上次使用的知识库路径。

## 🚀 如何使用

### 1. 环境准备

本工具基于 Python 开发，并使用 [Textual](https://github.com/Textualize/textual) 框架构建 TUI。请确保您的系统已安装 Python 3.7+。

### 2. 安装依赖

在您的终端中，克隆或下载项目后，使用 `pip` 通过 `requirements.txt` 文件安装所有必要的库：

```bash
pip install -r requirements.txt
```

### 3. 运行程序

通过项目的主入口文件 `main.py` 来启动本工具：

```bash
python main.py
```

程序启动后，请在“基础设置”页面中填入您 Logseq 知识库的**绝对路径**，然后点击“建立/更新缓存”，完成后即可开始使用各项功能。

## 📂 文件结构

项目遵循关注点分离原则，将代码解耦到不同的模块中，以提高可维护性和可扩展性。

```
.
├── main.py             # 🔵 应用主入口
├── ui.py               # 🎨 用户界面与交互逻辑 (View & Controller)
├── core.py             # ⚙️ 核心解析逻辑 (Model)
├── cache.py            # ⚡ 智能缓存管理模块
├── config.py           # 💾 用户配置的加载与保存
├── requirements.txt    # 📦 Python 依赖列表
└── README.md           # 📄 项目说明文档
```

- **`main.py`**: 职责单一，仅用于实例化并运行 `LogseqTUI` 应用。
- **`ui.py`**: 定义了应用的所有视觉组件和用户交互。它作为总协调者，接收用户输入，调用 `cache.py` 执行缓存任务，调用 `core.py` 执行解析，并负责将结果渲染到界面上。
- **`core.py`**: 剥离了文件扫描和遍历逻辑，现在专注于最核心的任务：解析单个 Markdown 文件内容并提取属性。
- **`cache.py`**: **项目性能核心**。封装了所有与缓存相关的操作，包括智能检测文件变动、增量更新、加载和保存缓存。
- **`config.py`**: 将配置读写逻辑从主应用中分离出来，使其易于管理。

## 📐 架构与设计哲学

本工具在 v2.0 中经历了重要的架构演进，核心设计哲学如下：

1.  **缓存优先 (Cache-First)**:
    这是最重要的架构升级。旧版每次操作都需要全量扫描文件系统，耗时严重。新架构下，所有的数据查询和分析都**基于缓存**进行。`ui.py` 在执行任何操作前，会先调用 `cache.py` 确保缓存是最新的。这种模式将耗时的 I/O 操作降到最低，带来了质的性能飞跃。

2.  **职责更加明确 (Refined Separation of Concerns)**:
    - `ui.py` 不再直接管理文件扫描，而是扮演**指挥官**的角色，向 `cache.py` 发出“更新缓存”的指令。
    - `core.py` 的职责被简化，只做一件事：**解析文本**。它像一个纯函数工具，输入文件内容，输出结构化数据，不关心文件来自哪里或如何被管理。
    - `cache.py` 成为专业的**数据管家**，负责数据的时效性、完整性和持久化。

3.  **异步执行与线程安全 (Asynchronous & Thread-Safe)**:
    所有耗时操作（如建立缓存、执行查询）都在后台线程中执行。`ui.py` 通过 `app.call_from_thread` 将结果安全地回调给 UI 线程进行界面更新，确保了即使用户在处理大型知识库时，界面也绝不会卡顿。

## 🌱 未来开发指南

我们鼓励对该工具进行持续改进。如果您希望贡献代码或进行二次开发，请遵循以下约定：

1.  **维持职责分离**:
    - 任何与文件系统交互、缓存管理相关的逻辑，都应在 `cache.py` 中扩展。
    - 任何与属性解析、文本处理相关的逻辑，都应添加到 `core.py` 中。
    - `ui.py` 继续作为用户交互和流程控制的中心。

2.  **数据流向**:
    始终遵循 `用户操作 (UI) -> 缓存检查 (Cache) -> 数据处理 (Core) -> 界面更新 (UI)` 的核心数据流。

3.  **代码风格**:
    - 遵循 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 代码风格指南。
    - 为所有新的函数和类编写清晰的文档字符串（Docstrings）。

通过遵循这些原则，我们可以确保项目在不断迭代中依然保持高质量和高可维护性。
